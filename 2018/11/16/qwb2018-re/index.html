<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>qwb2018-re | xrivendell7</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="picture_lock这是一个图片加密锁应用，主要功能是：  选择手机中的图片文件 使用Native代码（C&#x2F;C++）对图片进行加密 将加密后的文件保存为.lock格式 显示已加密的文件列表  目标是将某个加密后的文件解密出来，flag 就在里面。 mainactivity分析直接找到点击事件ENCRYPT按钮绑定的OnClick()方法: .juownvjvqjyo{zoom:80%">
<meta property="og:type" content="article">
<meta property="og:title" content="qwb2018-re">
<meta property="og:url" content="http://example.com/2018/11/16/qwb2018-re/index.html">
<meta property="og:site_name" content="xrivendell7">
<meta property="og:description" content="picture_lock这是一个图片加密锁应用，主要功能是：  选择手机中的图片文件 使用Native代码（C&#x2F;C++）对图片进行加密 将加密后的文件保存为.lock格式 显示已加密的文件列表  目标是将某个加密后的文件解密出来，flag 就在里面。 mainactivity分析直接找到点击事件ENCRYPT按钮绑定的OnClick()方法: .juownvjvqjyo{zoom:80%">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2018/11/16/qwb2018-re/image-20250826215213134.png">
<meta property="og:image" content="http://example.com/2018/11/16/qwb2018-re/image-20250826215307964.png">
<meta property="og:image" content="http://example.com/2018/11/16/qwb2018-re/image-20250826215346430.png">
<meta property="og:image" content="http://example.com/2018/11/16/qwb2018-re/image-20250826215409020.png">
<meta property="og:image" content="http://example.com/2018/11/16/qwb2018-re/image-20250826215441073.png">
<meta property="og:image" content="http://example.com/2018/11/16/qwb2018-re/image-20250827095440764.png">
<meta property="og:image" content="http://example.com/2018/11/16/qwb2018-re/image-20250827100132266.png">
<meta property="og:image" content="http://example.com/2018/11/16/qwb2018-re/image-20250904101123407.png">
<meta property="og:image" content="http://example.com/2018/11/16/qwb2018-re/flag.jpg">
<meta property="og:image" content="http://example.com/2018/11/16/qwb2018-re/image-20250911155632129.png">
<meta property="og:image" content="http://example.com/2018/11/16/qwb2018-re/image-20250911155911810.png">
<meta property="og:image" content="http://example.com/2018/11/16/qwb2018-re/image-20250911161638344.png">
<meta property="og:image" content="http://example.com/image-20250911201625976.png">
<meta property="article:published_time" content="2018-11-16T02:48:56.000Z">
<meta property="article:modified_time" content="2025-11-22T01:13:00.894Z">
<meta property="article:author" content="xrivendell7">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2018/11/16/qwb2018-re/image-20250826215213134.png">
  
    <link rel="alternate" href="/atom.xml" title="xrivendell7" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 8.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">xrivendell7</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-qwb2018-re" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/11/16/qwb2018-re/" class="article-date">
  <time class="dt-published" datetime="2018-11-16T02:48:56.000Z" itemprop="datePublished">2018-11-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      qwb2018-re
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="picture-lock"><a href="#picture-lock" class="headerlink" title="picture_lock"></a>picture_lock</h2><p>这是一个<strong>图片加密锁应用</strong>，主要功能是：</p>
<ol>
<li>选择手机中的图片文件</li>
<li>使用Native代码（C&#x2F;C++）对图片进行加密</li>
<li>将加密后的文件保存为<code>.lock</code>格式</li>
<li>显示已加密的文件列表</li>
</ol>
<p><strong>目标是将某个加密后的文件解密出来，flag 就在里面。</strong></p>
<h3 id="mainactivity分析"><a href="#mainactivity分析" class="headerlink" title="mainactivity分析"></a>mainactivity分析</h3><p>直接找到点击事件ENCRYPT按钮绑定的OnClick()方法:</p>
<style>.juownvjvqjyo{zoom:80%;}</style><img src="/2018/11/16/qwb2018-re/image-20250826215213134.png" class="juownvjvqjyo" alt="image-20250826215213134">

<p>可以看出，代码首先检查了文件读写的权限，然后打开了图片选择的界面，选择图片后，会调用方法onActivityResult()：</p>
<style>.zlojlqokjmbb{}</style><img src="/2018/11/16/qwb2018-re/image-20250826215307964.png" class="zlojlqokjmbb" alt="image-20250826215307964">

<p>可以看到这里有3个方法被调用了，分别是enc()，j()，i()。</p>
<style>.tbztkeqxmpxe{}</style><img src="/2018/11/16/qwb2018-re/image-20250826215346430.png" class="tbztkeqxmpxe" alt="image-20250826215346430">

<p>可以看出i()使用来显示文本框中的内容，对图片的处理没有影响</p>
<style>.vlykqgojcwxp{}</style><img src="/2018/11/16/qwb2018-re/image-20250826215409020.png" class="vlykqgojcwxp" alt="image-20250826215409020">

<p>j()用于获取apk签名的MD5值</p>
<style>.kalyyejleoxr{}</style><img src="/2018/11/16/qwb2018-re/image-20250826215441073.png" class="kalyyejleoxr" alt="image-20250826215441073">

<p>根据enc()方法的声明，可以知道，方法需要三个String类型的参数，这三个参数具体是什么，我们用动态调试的方法获取。</p>
<hr>
<h3 id="动态调试-so文件"><a href="#动态调试-so文件" class="headerlink" title="动态调试.so文件"></a>动态调试.so文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb push &quot;%USERPROFILE%\Downloads\bootloader-bonito-b4s4-0.4-8048689.img&quot; /sdcard/Download/</span><br><span class="line">#查看文件列表</span><br><span class="line">adb shell ls -la /sdcard/Download/</span><br></pre></td></tr></table></figure>

<p>root： <a target="_blank" rel="noopener" href="https://sspai.com/post/76276">https://sspai.com/post/76276</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LOAD:00000000 ; Options     : EF_ARM_SOFT_FLOAT</span><br><span class="line">LOAD:00000000 ; EABI version: 5</span><br><span class="line">LOAD:00000000 ;</span><br><span class="line">LOAD:00000000</span><br><span class="line">LOAD:00000000 ; Processor       : ARM</span><br><span class="line">LOAD:00000000 ; ARM architecture: ARMv7</span><br><span class="line">LOAD:00000000 ; Target assembler: Generic assembler for ARM</span><br><span class="line">LOAD:00000000 ; Byte sex        : Little endian</span><br><span class="line"></span><br><span class="line">LOAD:00000000 ; Segment type: Pure code</span><br><span class="line">LOAD:00000000                 AREA LOAD, CODE, ALIGN=12</span><br><span class="line">LOAD:00000000                 CODE32</span><br></pre></td></tr></table></figure>

<p><strong>IDA PRO连接调试应用</strong><br>(1)在IDA Pro的安装路径dbgsrv目录下找到android_server，放入真机的&#x2F;data&#x2F;local&#x2F;tmp路径下并赋权，以root身份运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adb push android_server /data/local/tmp </span><br><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">cd /data/local/tmp</span><br><span class="line">chmod 755 android_server64</span><br><span class="line">./android_server64</span><br></pre></td></tr></table></figure>

<style>.ochpydnyhnyl{}</style><img src="/2018/11/16/qwb2018-re/image-20250827095440764.png" class="ochpydnyhnyl" alt="image-20250827095440764">

<p>(2)转发窗口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:23946 tcp:23946  </span><br></pre></td></tr></table></figure>

<style>.nvuopslifskt{}</style><img src="/2018/11/16/qwb2018-re/image-20250827100132266.png" class="nvuopslifskt" alt="image-20250827100132266">

<p>打开ida32位</p>
<p>Deubugger-Attach-Remote ARM Linux&#x2F;Android debugger</p>
<p>查看libnative.so是否已经运行，打开enc()函数。下断点。</p>
<style>.yeirdtycyohg{}</style><img src="/2018/11/16/qwb2018-re/image-20250904101123407.png" class="yeirdtycyohg" alt="image-20250904101123407">

<p>打开app-选择照片-手机黑屏-断到了</p>
<hr>
<h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>静态看吧，主要就是这个enc()。native方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall Java_com_a_sample_picturelock_MainActivity_enc(int a1, int a2, int a3, int a4, int a5)</span><br><span class="line">&#123;</span><br><span class="line">  char *v8; // r4</span><br><span class="line">  int v9; // r6</span><br><span class="line">  const void *v10; // r11</span><br><span class="line"></span><br><span class="line">  v8 = (char *)(*(int (__fastcall **)(int, int, _DWORD))(*(_DWORD *)a1 + 676))(a1, a3, 0);</span><br><span class="line">  v9 = (*(int (__fastcall **)(int, int, _DWORD))(*(_DWORD *)a1 + 676))(a1, a4, 0);</span><br><span class="line">  if ( !dword_600C )</span><br><span class="line">  &#123;</span><br><span class="line">    dword_600C = (int)malloc(0x20u);</span><br><span class="line">    v10 = (const void *)(*(int (__fastcall **)(int, int, _DWORD))(*(_DWORD *)a1 + 676))(a1, a5, 0);</span><br><span class="line">    qmemcpy((void *)dword_600C, v10, 0x20u);</span><br><span class="line">    (*(void (__fastcall **)(int, int, const void *))(*(_DWORD *)a1 + 680))(a1, a5, v10);</span><br><span class="line">  &#125;</span><br><span class="line">  sub_1A48(v8);</span><br><span class="line">  (*(void (__fastcall **)(int, int, char *))(*(_DWORD *)a1 + 680))(a1, a3, v8);</span><br><span class="line">  return (*(int (__fastcall **)(int, int, int))(*(_DWORD *)a1 + 680))(a1, a4, v9);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sub_1A48函数：一些加密算法</p>
<p>此函数是一个典型的<strong>文件加解密&#x2F;转换工具</strong>的核心逻辑，主要功能为：</p>
<ul>
<li><strong>初始化阶段</strong>：首次调用时生成内部状态（疑似密钥调度或预处理）。</li>
<li><strong>文件处理阶段</strong>：从输入文件 <code>filename</code> 读取数据 → 经复杂变换 → 写入输出文件 <code>a2</code></li>
</ul>
<p>基本流程：</p>
<ol>
<li>将传入的签名的 md5 字符串分为两半，生成两组密钥。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v5 = dword_600C;</span><br><span class="line">    for ( i = 0; i != 4; ++i )</span><br><span class="line">      v4[i] = _byteswap_ulong(*(_DWORD *)(v5 + i * 4));</span><br><span class="line">      </span><br><span class="line">v29 = &amp;dword_6008;</span><br><span class="line">if ( (v24 &amp; 1) == 0 )</span><br><span class="line">	v29 = &amp;dword_6004;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>每次读入 md5sig[k &amp; 0x1F] 大小的内容</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v24 = *(_BYTE *)(dword_600C + (k &amp; 0x1F));</span><br></pre></td></tr></table></figure>

<ul>
<li><code>k &amp; 0x1F</code> 等价于 <code>k % 32</code>，即循环使用 <code>dword_600C</code> 的前 32 字节作为每轮读取长度表。</li>
</ul>
<p><code>fread(v20, 1u, v24, v21)</code> 按此长度读取数据。</p>
<ol start="3">
<li>根据读入的大小决定使用哪一组密钥</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ((v24 &amp; 1) == 0) v29 = &amp;dword_6004;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据当前块长度 <code>v24</code> 的奇偶性选择 IV 基址（<code>dword_6004</code> 或 <code>dword_6008</code>）。</li>
</ul>
<ol start="4">
<li>奇数使用第二组密钥，偶数使用第一组密钥</li>
</ol>
<ul>
<li>当 <code>v24</code> 为奇数时，<code>(v24 &amp; 1) != 0</code>，默认使用 <code>dword_6008</code>；</li>
<li>当 <code>v24</code> 为偶数时，强制切换为 <code>dword_6004</code>。</li>
</ul>
<ol start="5">
<li>如果读入的大小不够 16 的话，就将后面填充为不够的大小（比如大小为 12 时，填充 4 个 0x4）</li>
</ol>
<ul>
<li><code>if (v25 &lt;= 0xF)</code> 触发填充逻辑；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memset(v27, (unsigned __int8)v28, 16 - (v26 &amp; 0xF));</span><br></pre></td></tr></table></figure>

<ul>
<li>填充值为 <code>v28 = 16 - (v26 &amp; 0xF)</code>，即填充长度本身。</li>
</ul>
<ol start="6">
<li>这时修改后的内容必然够 16 个字节，对前 16 个字节进行 AES 加密。对于后面的字节，将其与 md5sig[k &amp; 0x1F] 依次进行异或。</li>
</ol>
<ul>
<li><strong>前 16 字节</strong>：经过复杂的多轮变换（<code>sub_132C</code>, <code>sub_13B0</code> 等），最终写入 <code>v22</code> 的前 16 字节。</li>
<li><strong>后续字节</strong>：<code>if (v26 &gt;= 0x11)</code> 分支中，对超出 16 字节的部分执行 <code>v22[v31] = v20[v31] ^ (BYTE)(v32 + v31%32)</code>，即与 <code>dword_600C</code> 的循环值异或。</li>
</ul>
<p>使用keytool工具获取签名的 md5</p>
<p>android中关于keytool 错误：java.lang.Exception：密钥库文件不存在: 解决步骤_keytool 错误: java.lang.exception: 密钥库文件不存在: debug.k-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/y201314an/article/details/80994798">https://blog.csdn.net/y201314an/article/details/80994798</a>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#keytool -printcert -jarfile D:\CTF\2018reverse\picturelock\picturelock.apk</span><br><span class="line"></span><br><span class="line">签名者 #1:</span><br><span class="line"></span><br><span class="line">证书 #1：</span><br><span class="line">所有者: CN=a, OU=b, O=c, L=d, ST=e, C=ff</span><br><span class="line">发布者: CN=a, OU=b, O=c, L=d, ST=e, C=ff</span><br><span class="line">序列号: 5f4e6be1</span><br><span class="line">生效时间: Fri Sep 09 14:32:36 CST 2016, 失效时间: Tue Sep 03 14:32:36 CST 2041</span><br><span class="line">证书指纹:</span><br><span class="line">         SHA1: 48:E7:04:5E:E6:0D:9D:8A:25:7C:52:75:E3:65:06:09:A5:CC:A1:3E</span><br><span class="line">         SHA256: BA:12:C1:3F:D6:0E:0D:EF:17:AE:3A:EE:4E:6A:81:67:82:D0:36:7F:F0:2E:37:CC:AD:5D:6E:86:87:0C:8E:38</span><br><span class="line">签名算法名称: SHA256withRSA</span><br><span class="line">主体公共密钥算法: 2048 位 RSA 密钥</span><br><span class="line">版本: 3</span><br><span class="line"></span><br><span class="line">扩展:</span><br><span class="line"></span><br><span class="line">#1: ObjectId: 2.5.29.14 Criticality=false</span><br><span class="line">SubjectKeyIdentifier [</span><br><span class="line">KeyIdentifier [</span><br><span class="line">0000: 71 A3 2A FB D3 F4 A9 A9   2A 74 3F 29 8E 67 8A EA  q.*.....*t?).g..</span><br><span class="line">0010: 3B DD 30 E3                                        ;.0.</span><br><span class="line">]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>获取md5需要openssl，太大了下不下来啊。</p>
<p>反正MD5:  F8:C4:90:56:E4:CC:F9:A1:1E:09:0E:AF:47:1F:41:8D</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">import itertools</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line">sig = b&#x27;f8c49056e4ccf9a11e090eaf471f418d&#x27;</span><br><span class="line"></span><br><span class="line">def decode_sig(payload):</span><br><span class="line">    ans = bytearray()  # 使用 bytearray 代替字符串</span><br><span class="line">    for i in range(len(payload)):</span><br><span class="line">        # 执行异或操作并直接追加字节</span><br><span class="line">        ans.append(payload[i] ^ sig[(16 + i) % 32])</span><br><span class="line">    return bytes(ans)  # 转换为不可变 bytes 类型</span><br><span class="line"></span><br><span class="line">def dec_aes():</span><br><span class="line">    with open(&#x27;flag.jpg.lock&#x27;, &#x27;rb&#x27;) as data_file:</span><br><span class="line">        data = data_file.read()</span><br><span class="line">    </span><br><span class="line">    with open(&#x27;flag.jpg&#x27;, &#x27;wb&#x27;) as f:  # 确保文件以二进制模式打开</span><br><span class="line">        idx = 0</span><br><span class="line">        i = 0</span><br><span class="line">        cipher1 = AES.new(sig[:0x10], AES.MODE_ECB)</span><br><span class="line">        cipher2 = AES.new(sig[0x10:], AES.MODE_ECB)</span><br><span class="line">        </span><br><span class="line">        while idx &lt; len(data):</span><br><span class="line">            read_len = sig[i % 32]</span><br><span class="line">            payload = data[idx:idx + read_len]</span><br><span class="line">            print(f&#x27;[+] Totally &#123;idx&#125; / &#123;len(data)&#125; bytes, sig index : &#123;i&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">            if read_len % 2 == 0:</span><br><span class="line">                f.write(cipher1.decrypt(payload[:0x10]))</span><br><span class="line">            else:</span><br><span class="line">                f.write(cipher2.decrypt(payload[:0x10]))</span><br><span class="line">            </span><br><span class="line">            # 关键修改：decode_sig 现在返回 bytes，可直接写入二进制文件</span><br><span class="line">            f.write(decode_sig(payload[16:]))</span><br><span class="line">            f.flush()</span><br><span class="line">            idx += read_len</span><br><span class="line">            i += 1</span><br><span class="line">        print(&#x27;[+] Decoding done ...&#x27;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    dec_aes()</span><br></pre></td></tr></table></figure>

<p>得到解密出来的flag.jpg</p>
<style>.ikmrsrvtvlrg{zoom: 33%;}</style><img src="/2018/11/16/qwb2018-re/flag.jpg" class="ikmrsrvtvlrg" alt="flag">

<h3 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a><strong>补充知识点</strong></h3><p>smali</p>
<p>smali是andriod虚拟机的反汇编语言</p>
<p>openssl x509 -noout -modulus -in client.crt | openssl md5<br>openssl rsa -noout -modulus -in client.key | openssl md5</p>
<h2 id="simple-check"><a href="#simple-check" class="headerlink" title="simple check"></a>simple check</h2><h3 id="simple的mainactivity-kt分析"><a href="#simple的mainactivity-kt分析" class="headerlink" title="simple的mainactivity.kt分析"></a>simple的mainactivity.kt分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.a.simplecheck;</span><br><span class="line"></span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.support.v7.app.c;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.widget.EditText;</span><br><span class="line">import android.widget.Toast;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>包名</strong>：<code>com.a.simplecheck</code>，表明这是一个简单的检查类应用</li>
<li><strong>导入语句</strong>：使用了Android Support库（v7），说明这是一个较老的项目</li>
</ul>
<p>这是一个<strong>密码验证程序</strong>，其工作流程为：</p>
<ol>
<li>用户在一个文本输入框（EditText）中输入内容</li>
<li>点击一个按钮进行验证</li>
<li>程序调用<code>a.a(String)</code>方法对输入进行验证</li>
<li>根据验证结果显示不同的Toast消息</li>
</ol>
<p>关键逆向分析点：</p>
<ol>
<li><strong>核心逻辑在类<code>a</code>的方法<code>a()</code>中</strong></li>
<li><strong>验证算法</strong>：<code>a.a(String input)</code>是验证的核心方法</li>
<li><strong>成功条件</strong>：当输入满足某种算法时返回<code>true</code></li>
</ol>
<h3 id="类a分析"><a href="#类a分析" class="headerlink" title="类a分析"></a>类a分析</h3><p>这个 <code>a</code> 类包含了验证flag的完整算法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class a &#123;</span><br><span class="line">    private static int[] a = &#123;0, 146527998, 205327308, ... , 864054312&#125;;</span><br><span class="line">    private static int[] b = &#123;13710, 46393, 49151, ... , 37108&#125;;</span><br><span class="line">    private static int[] c = &#123;38129, 57355, 22538, ... , 64666&#125;;</span><br><span class="line">    private static int[] d = &#123;0, -341994984, -370404060, ... , 276158562&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义了4个静态数组，包含预计算的常数</li>
<li>数组 <code>a</code> 有35个元素，<code>b</code>、<code>c</code>、<code>d</code> 各有34个元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static boolean a(String str) &#123;</span><br><span class="line">    if (str.length() != b.length) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>第一重检查</strong>：输入字符串长度必须等于数组 <code>b</code> 的长度（34个字符）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int[] iArr = new int[a.length];</span><br><span class="line">iArr[0] = 0;</span><br><span class="line">int i = 1;</span><br><span class="line">for (byte b2 : str.getBytes()) &#123;</span><br><span class="line">    iArr[i] = b2;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将输入字符串转换为ASCII码数组</li>
<li><code>iArr[0]</code> 被设为0，然后依次填充输入字符串的每个字符的ASCII值</li>
<li>最终 <code>iArr</code> 数组有35个元素（索引0到34）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i2 = 0; i2 &lt; c.length; i2++) &#123;</span><br><span class="line">    if (a[i2] != (b[i2] * iArr[i2] * iArr[i2]) + (c[i2] * iArr[i2]) + d[i2] </span><br><span class="line">        || a[i2 + 1] != (b[i2] * iArr[i2 + 1] * iArr[i2 + 1]) + (c[i2] * iArr[i2 + 1]) + d[i2]) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br></pre></td></tr></table></figure>

<p>遍历34次，检查二次方程约束</p>
<p><strong>验证模型</strong></p>
<p>对于i从0到33，必须满足以下两个方程其中之一：</p>
<p>方程1：<br>$$<br>a[i] &#x3D; b[i] * (x_i)² + c[i] * x_i + d[i]<br>$$<br>方程2：<br>$$<br>a[i + 1] &#x3D; b[i] * (x_{i+1})² + c[i] * x_{i+1} + d[i]<br>$$</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>暴力破解就行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">a = [0, 146527998, 205327308, 94243885, 138810487, 408218567, 77866117, 71548549, 563255818, 559010506, 449018203, 576200653, 307283021, 467607947, 314806739, 341420795, 341420795, 469998524, 417733494, 342206934, 392460324, 382290309, 185532945, 364788505, 210058699, 198137551, 360748557, 440064477, 319861317, 676258995, 389214123, 829768461, 534844356, 427514172, 864054312]</span><br><span class="line">b = [13710, 46393, 49151, 36900, 59564, 35883, 3517, 52957, 1509, 61207, 63274, 27694, 20932, 37997, 22069, 8438, 33995, 53298, 16908, 30902, 64602, 64028, 29629, 26537, 12026, 31610, 48639, 19968, 45654, 51972, 64956, 45293, 64752, 37108]</span><br><span class="line">c = [38129, 57355, 22538, 47767, 8940, 4975, 27050, 56102, 21796, 41174, 63445, 53454, 28762, 59215, 16407, 64340, 37644, 59896, 41276, 25896, 27501, 38944, 37039, 38213, 61842, 43497, 9221, 9879, 14436, 60468, 19926, 47198, 8406, 64666]</span><br><span class="line">d = [0, -341994984, -370404060, -257581614, -494024809, -135267265, 54930974, -155841406, 540422378, -107286502, -128056922, 265261633, 275964257, 119059597, 202392013, 283676377, 126284124, -68971076, 261217574, 197555158, -12893337, -10293675, 93868075, 121661845, 167461231, 123220255, 221507, 258914772, 180963987, 107841171, 41609001, 276531381, 169983906, 276158562]</span><br><span class="line"></span><br><span class="line">result = [0]</span><br><span class="line"></span><br><span class="line">for i in range(34):</span><br><span class="line">    found = False</span><br><span class="line">    for char_code in range(32,127):</span><br><span class="line">        if a[i + 1] == b[i] * char_code * char_code + c[i] * char_code + d[i]:</span><br><span class="line">            result.append(char_code)</span><br><span class="line">            found = True</span><br><span class="line">            break</span><br><span class="line">        </span><br><span class="line">    if not found:</span><br><span class="line">        print(f&quot;在位置 &#123;i&#125; 找不到满足方程的字符&quot;)</span><br><span class="line">        break</span><br><span class="line">    </span><br><span class="line"># 将ASCII码转换为字符串</span><br><span class="line">flag = &#x27;&#x27;.join(chr(code) for code in result)</span><br><span class="line">print(&quot;Flag:&quot;, flag)</span><br><span class="line"></span><br><span class="line">#Flag: flag&#123;MAth_i&amp;_GOOd_DON7_90V_7hInK?&#125;</span><br></pre></td></tr></table></figure>



<p><strong>补充知识点</strong></p>
<p><strong>什么是 Toast？</strong></p>
<p><strong>Toast</strong> 是一个小的弹出消息框，它在屏幕底部短暂显示一段时间，然后自动消失。它用于向用户提供简单的反馈或提示信息。</p>
<h2 id="hide"><a href="#hide" class="headerlink" title="hide"></a>hide</h2><p>[<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-251371.htm">原创]从2018强网杯hide题中学习手动脱壳与算法识别的思路-CTF对抗-看雪-安全社区|安全招聘|kanxue.com</a></p>
<p>先查壳，稍微折腾了一下，PEiD查不到壳，选择使用strings命令。windows下没有strings，下载git，git也不能用，最终选择MSYS2。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pacman -Syu</span><br><span class="line">pacman -S mingw-w64-x86_64-binutils</span><br><span class="line">cd /d/CTF/2018reverse/hide</span><br><span class="line">strings hide | grep -i upx</span><br></pre></td></tr></table></figure>

<p>查看结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ strings hide | grep -i upx</span><br><span class="line">UPX!</span><br><span class="line">$Info: This file is packed with the UPX executable packer http://upx.sf.net $</span><br><span class="line">$Id: UPX 3.91 Copyright (C) 1996-2013 the UPX Team. All Rights Reserved. $</span><br><span class="line">UPX!</span><br><span class="line">UPX!</span><br></pre></td></tr></table></figure>

<p>这个文件 <strong><code>hide</code></strong> 使用了 <strong>UPX 3.91</strong> 版本进行加壳压缩。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PS D:\CTF\2018reverse\hide&gt; upx -d hide</span><br><span class="line">                       Ultimate Packer for eXecutables</span><br><span class="line">                          Copyright (C) 1996 - 2025</span><br><span class="line">UPX 5.0.2       Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Jul 20th 2025</span><br><span class="line"></span><br><span class="line">        File size         Ratio      Format      Name</span><br><span class="line">   --------------------   ------   -----------   -----------</span><br><span class="line">upx: hide: CantUnpackException: unknown format 0</span><br><span class="line"></span><br><span class="line">Unpacked 0 files.</span><br></pre></td></tr></table></figure>

<p>需要手动脱壳，使用file命令查看文件信息，是个Linux文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file hide</span><br><span class="line">hide: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, no section header</span><br></pre></td></tr></table></figure>

<p>具体做法是让程序先运行，然后等到数据自动解压&#x2F;解密出来后，再dump内存组成elf文件进行分析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;./hide</span><br><span class="line">&gt; pgrep -fl hide</span><br><span class="line">&gt; pmap -d 21895</span><br><span class="line">&gt; dd if=/proc/$(pidof hide)/mem of=hide_dump1 skip=4194304  bs=1c count=827392</span><br><span class="line"></span><br><span class="line">&gt; file hide_dump1</span><br><span class="line">hide_dump1: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, missing section headers at 840568</span><br><span class="line"></span><br><span class="line">&gt; dd if=/proc/$(pidof hide)/mem of=hide_dump2 skip=7110656 bs=1 count=20480</span><br><span class="line">&gt; cat hide_dump1 hide_dump2 &gt; hide_dump</span><br><span class="line"></span><br><span class="line">&gt; file hide_dump</span><br><span class="line">hide_dump: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, stripped</span><br></pre></td></tr></table></figure>

<p>然后就获得了完整的脱壳后的文件。</p>
<p>静态分析</p>
<p>将<code>hide_dump</code>载入ida，按下<code>Shift</code>+<code>F12</code>查看字符串列表并搜索<code>flag</code>:</p>
<style>.bxwfatepafzf{}</style><img src="/2018/11/16/qwb2018-re/image-20250911155632129.png" class="bxwfatepafzf" alt="image-20250911155632129">

<p>敏感字符串aYouAreRight，查看交叉引用：</p>
<style>.nrxesyunaoyt{zoom:67%;}</style><img src="/2018/11/16/qwb2018-re/image-20250911155911810.png" class="nrxesyunaoyt" alt="image-20250911155911810">

<p>查看sub_4009EF函数：</p>
<style>.puklxilfixjb{zoom:80%;}</style><img src="/2018/11/16/qwb2018-re/image-20250911161638344.png" class="puklxilfixjb" alt="image-20250911161638344">

<p>这肯定不对，看下一个函数：</p>
<p><img src="/image-20250911201625976.png" alt="image-20250911201625976"></p>
<p>进入这个地址，发现ida没有将其识别称为一个函数，我们需要手动逆向分析。这通常发生在加壳、混淆或编译器优化过的代码中。</p>
<h3 id="逆向工程中的手动分析操作"><a href="#逆向工程中的手动分析操作" class="headerlink" title="逆向工程中的手动分析操作"></a><strong>逆向工程中的手动分析操作</strong></h3><p>反编译之后跟题解不一样</p>
<p>向上查看代码，寻找合适的函数起点</p>
<p><code>0x4C8EF4</code> 这个位置具有函数开头的典型特征（如ret或jmp后面基本就是一个函数的开头）</p>
<p>使用 <strong>Create Function</strong> 功能强制 IDA 将该地址识别为函数开头</p>
<p>这是个先验证后加密的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">signed __int64 sub_4C8EF4()</span><br><span class="line">&#123;</span><br><span class="line">  char *v0; // rdi</span><br><span class="line">  __int64 *v1; // rsi</span><br><span class="line">  unsigned __int64 i; // rdx</span><br><span class="line"></span><br><span class="line">  if ( strlen(qword_6CCDB0) == 21  //验证</span><br><span class="line">    &amp;&amp; qword_6CCDB0[1] == &#x27;w&#x27;</span><br><span class="line">    &amp;&amp; qword_6CCDB0[2] == &#x27;b&#x27;</span><br><span class="line">    &amp;&amp; qword_6CCDB0[3] == &#x27;&#123;&#x27;</span><br><span class="line">    &amp;&amp; qword_6CCDB0[20] == &#x27;&#125;&#x27; )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_4C8CC0((__int64)&amp;qword_6CCDB0[4]);</span><br><span class="line">    sub_4C8E50(&amp;qword_6CCDB0[4]);</span><br><span class="line">    sub_4C8CC0((__int64)&amp;qword_6CCDB0[4]);</span><br><span class="line">    sub_4C8E50(&amp;qword_6CCDB0[4]);</span><br><span class="line">    sub_4C8CC0((__int64)&amp;qword_6CCDB0[4]);</span><br><span class="line">    v0 = &amp;qword_6CCDB0[4];</span><br><span class="line">    sub_4C8E50(&amp;qword_6CCDB0[4]);</span><br><span class="line">    v1 = qword_4C8CB0;// 加载预存的标准答案</span><br><span class="line">    for ( i = 0LL; i &lt; 0x10 &amp;&amp; *v0 == *(_BYTE *)v1; ++i )//逐字节比对</span><br><span class="line">    &#123;</span><br><span class="line">      ++v0;</span><br><span class="line">      v1 = (__int64 *)((char *)v1 + 1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  __asm &#123; syscall; LINUX - sys_write &#125;</span><br><span class="line">  return sys_exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>flag的格式为qwb{x*16}</p>
<p>进入sub_4C8CC0，很像tea加密：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 __fastcall sub_4C8CC0(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int64 result; // rax</span><br><span class="line">  unsigned int v2; // [rsp+18h] [rbp-48h]</span><br><span class="line">  unsigned int v3; // [rsp+1Ch] [rbp-44h]</span><br><span class="line">  unsigned int v4; // [rsp+20h] [rbp-40h]</span><br><span class="line">  int i; // [rsp+24h] [rbp-3Ch]</span><br><span class="line">  int j; // [rsp+28h] [rbp-38h]</span><br><span class="line">  int v7[6]; // [rsp+40h] [rbp-20h] BYREF</span><br><span class="line">  unsigned __int64 v8; // [rsp+58h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(0x28u);</span><br><span class="line">  qmemcpy(v7, &quot;s1IpP3rEv3Ryd4Y3&quot;, 16);</span><br><span class="line">  for ( i = 0; i &lt;= 1; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = 0;</span><br><span class="line">    v2 = *(_DWORD *)(8 * i + a1);</span><br><span class="line">    v3 = *(_DWORD *)(a1 + 4 + 8 * i);</span><br><span class="line">    for ( j = 0; j &lt;= 7; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 += (v7[v4 &amp; 3] + v4) ^ (((v3 &gt;&gt; 5) ^ (16 * v3)) + v3);</span><br><span class="line">      v4 += 0x676E696C;</span><br><span class="line">      v3 += (v7[(v4 &gt;&gt; 11) &amp; 3] + v4) ^ (((v2 &gt;&gt; 5) ^ (16 * v2)) + v2);</span><br><span class="line">    &#125;</span><br><span class="line">    *(_DWORD *)(a1 + 8 * i) = v2;</span><br><span class="line">    *(_DWORD *)(a1 + 4 + 8 * i) = v3;</span><br><span class="line">  &#125;</span><br><span class="line">  result = __readfsqword(0x28u) ^ v8;</span><br><span class="line">  if ( result )</span><br><span class="line">    return ((__int64 (*)(void))loc_4C8B9A)();</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_BYTE *__fastcall sub_4C8E50(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  _BYTE *result; // rax</span><br><span class="line">  int i; // [rsp+14h] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  for ( i = 0; i &lt;= 15; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (_BYTE *)(i + a1);</span><br><span class="line">    *result ^= i;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异或</p>
<h3 id="解密exp"><a href="#解密exp" class="headerlink" title="解密exp"></a>解密exp</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">keyPool = [1883844979, 1165112144, 2035430262, 861484132]</span><br><span class="line">array_car = [1735289196, 3470578392, 910900292, 2646189488, 86511388, 1821800584, 3557089780, 997411680]</span><br><span class="line">target = [0x7f13b852, 0x1bf28c35, 0xd28663f4, 0x311e4f73]</span><br><span class="line"></span><br><span class="line">def de_xor(enc):</span><br><span class="line">    for _i in range(4):</span><br><span class="line">        current = enc[_i]</span><br><span class="line">        a = current &amp; 0xFF</span><br><span class="line">        b = (current &amp; 0xFF00) &gt;&gt; 8</span><br><span class="line">        c = (current &amp; 0xFF0000) &gt;&gt; 16</span><br><span class="line">        d = (current &amp; 0xFF000000) &gt;&gt; 24</span><br><span class="line">        a ^= (_i * 4 + 0)</span><br><span class="line">        b ^= (_i * 4 + 1)</span><br><span class="line">        c ^= (_i * 4 + 2)</span><br><span class="line">        d ^= (_i * 4 + 3)</span><br><span class="line">        # 修正此处：添加缺失的位或运算符 |</span><br><span class="line">        enc[_i] = a | (b &lt;&lt; 8) | (c &lt;&lt; 16) | (d &lt;&lt; 24)</span><br><span class="line">    return enc</span><br><span class="line"></span><br><span class="line">def encrypt(i32_para1, i32_para2):</span><br><span class="line">    foo = i32_para1</span><br><span class="line">    bar = i32_para2</span><br><span class="line">    car = 0</span><br><span class="line">    for _i in range(8):</span><br><span class="line">        tmp_a = keyPool[(car &amp; 3)] + car</span><br><span class="line">        tmp_b = ((bar &gt;&gt; 5) ^ (bar &lt;&lt; 4)) + bar</span><br><span class="line">        foo += tmp_a ^ tmp_b</span><br><span class="line">        foo &amp;= 0xffffffff</span><br><span class="line">        car += 1735289196</span><br><span class="line">        car &amp;= 0xffffffff</span><br><span class="line">        tmp_a = keyPool[((car &gt;&gt; 11) &amp; 3)] + car</span><br><span class="line">        tmp_b = ((foo &gt;&gt; 5) ^ (16 * foo)) + foo</span><br><span class="line">        bar += tmp_a ^ tmp_b</span><br><span class="line">        bar &amp;= 0xffffffff</span><br><span class="line">    return foo, bar</span><br><span class="line"></span><br><span class="line">def solver(enc_foo, enc_bar):</span><br><span class="line">    foo = enc_foo</span><br><span class="line">    bar = enc_bar</span><br><span class="line">    car = array_car[7]</span><br><span class="line">    for _i in range(8):</span><br><span class="line">        tmp_a = keyPool[((car &gt;&gt; 11) &amp; 3)] + car</span><br><span class="line">        tmp_b = ((foo &gt;&gt; 5) ^ (16 * foo)) + foo</span><br><span class="line">        bar -= tmp_a ^ tmp_b</span><br><span class="line">        bar = (bar + 0xffffffff + 1) &amp; 0xffffffff</span><br><span class="line">        car -= 1735289196</span><br><span class="line">        car = (car + 0xffffffff + 1) &amp; 0xffffffff</span><br><span class="line">        tmp_a = keyPool[(car &amp; 3)] + car</span><br><span class="line">        tmp_b = ((bar &gt;&gt; 5) ^ (bar &lt;&lt; 4)) + bar</span><br><span class="line">        foo -= tmp_a ^ tmp_b</span><br><span class="line">        foo = (foo + 0xffffffff + 1) &amp; 0xffffffff</span><br><span class="line">    return foo, bar</span><br><span class="line"></span><br><span class="line"># 执行流程</span><br><span class="line">target = de_xor(target.copy())  # 避免修改原始列表</span><br><span class="line">print(&quot;=====&quot;)</span><br><span class="line">for t in target:</span><br><span class="line">    print(hex(t))</span><br><span class="line"></span><br><span class="line">for i in range(2):</span><br><span class="line">    target[i * 2], target[i * 2 + 1] = solver(target[i * 2], target[i * 2 + 1])</span><br><span class="line"></span><br><span class="line">print(&quot;=====&quot;)</span><br><span class="line">for t in target:</span><br><span class="line">    print(hex(t))</span><br><span class="line"></span><br><span class="line">target = de_xor(target.copy())</span><br><span class="line">print(&quot;=====&quot;)</span><br><span class="line">for t in target:</span><br><span class="line">    print(hex(t))</span><br><span class="line"></span><br><span class="line">for i in range(2):</span><br><span class="line">    target[i * 2], target[i * 2 + 1] = solver(target[i * 2], target[i * 2 + 1])</span><br><span class="line"></span><br><span class="line">print(&quot;=====&quot;)</span><br><span class="line">for t in target:</span><br><span class="line">    print(hex(t))</span><br><span class="line"></span><br><span class="line">target = de_xor(target.copy())</span><br><span class="line">print(&quot;=====&quot;)</span><br><span class="line">for t in target:</span><br><span class="line">    print(hex(t))</span><br><span class="line"></span><br><span class="line">for i in range(2):</span><br><span class="line">    target[i * 2], target[i * 2 + 1] = solver(target[i * 2], target[i * 2 + 1])</span><br><span class="line"></span><br><span class="line">print(&quot;=====&quot;)</span><br><span class="line">for t in target:</span><br><span class="line">    print(t)</span><br><span class="line"></span><br><span class="line"># 最终输出解码字符串</span><br><span class="line">print(&quot;=====&quot;)</span><br><span class="line">result = b&#x27;&#x27;.join([bytes.fromhex(hex(t)[2:])[::-1] for t in target]).decode(&#x27;utf-8&#x27;)</span><br><span class="line">print(result)  # 应输出 &quot;f1Nd_TH3HldeC0dE&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="baby-re"><a href="#baby-re" class="headerlink" title="baby_re"></a>baby_re</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/11/16/qwb2018-re/" data-id="cuidEac2FpQt1rlsf9j_KPAQj" data-title="qwb2018-re" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/12/17/2018bctf/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          2018 BCTF
        
      </div>
    </a>
  
  
    <a href="/2018/11/10/2018%E7%BD%91%E9%BC%91%E6%9D%AFctf/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">2018 网鼎杯ctf</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/11/">November 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/10/">October 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/09/">September 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">August 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/11/18/n1ctfjunior-re/">n1ctfjunior-re。</a>
          </li>
        
          <li>
            <a href="/2025/11/01/qwb2025-re/">qwb2025-re。</a>
          </li>
        
          <li>
            <a href="/2025/10/25/qwb2025-pwn/">qwb2025-pwn flagmarket。</a>
          </li>
        
          <li>
            <a href="/2025/10/10/junior/">n1ctf junior 2/2 web</a>
          </li>
        
          <li>
            <a href="/2025/10/09/2025crewctf/">crewCTF2025</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 xrivendell7<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>